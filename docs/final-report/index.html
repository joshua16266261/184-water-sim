<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>Realistic Water Simulation with Spray, Foam, and Bubbles</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>

<body>

<h1 align="middle">CS184: Realistic Water Simulation with Spray, Foam, and Bubbles </h1>

<h3 align="middle">Marcus Lee, Joshua Chen, Fourth Teerakapibal, Calvin Pham </h3>
<center><img src="./images/final-diffuse.gif"></center>

<h1 align="middle">Abstract</h1>

<h1 align="middle">Technical Approach</h1>
<h2 align="middle">Position-Based Fluid Simulation</h2>

<div align="middle">
    <img src="images/fluid-matplot.gif" align="middle" width="400px"/>
    <figcaption align="middle">Fluid particles in Matplotlib</figcaption>
</div>

<h2 align="middle">Adding Spray, Foam, and Bubbles</h2>
<p>
    Our main goal with this project was adding diffuse particles to fluid simulations, and our code architecture closely mirrors our fluid simulation architecture.
    <code>ParentFluid</code> is a struct which owns all the <code>DiffuseParticle</code> structs in the scene.
    <code>ParentFluid</code> also has a pointer to the <code>Fluid</code> for the scene, which allows it to access the positions and velocities of all the <code>Particle</code> structs in the scene.
    We implemented <a href="https://cg.informatik.uni-freiburg.de/publications/2012_CGI_sprayFoamBubbles.pdf" target="_blank" rel="noopener noreferrer">this paper</a> to advect and generate diffuse particles.
</p>
<!--
<h3>Pseudocode of Algorithm</h3>
<ol>
    <li>Build spatial map of fluid particles with grid width $2h$</li>
    <li>For all foam particles $i$:</li>
    <ol type="a">
        <li>If time to live of $i$ $\leq 0$: erase $i$</li>
        <li>Else: decrement time to live of $i$ by $\Delta t$</li>
    </ol>
    <li>For all diffuse particles:</li>
    <ol type="a">
        <li>Perform advection and collision detection/response</li>
    </ol>
    <li>Build spatial map of fluid particles with grid width $h$</li>
    <li>For all fluid particles $i$:</li>
    <ol type="a">
        <li>Calculate $\rho_i$ (as defined in <b>Position-Based Fluid Simulation</b>)</li>
    </ol>
    <li>For all fluid particles $i$:</li>
    <ol type="a">
        <li>Calculate the surface normal vector $\pmb{n}_i$ (as given by <a href="https://matthias-research.github.io/pages/publications/sca03.pdf" target="_blank" rel="noopener noreferrer">this paper</a>)</li>
    </ol>
    <li>For all fluid particles:</li>
    <ol type="a">
        <li>Calculate $n_d$ and generate diffuse particles</li>
    </ol>
</ol>
-->


<h3>Generation</h3>
<p>
    To determine the number of diffuse particles \(n_d\) that fluid particle \(i\) generates, we calculate \(I_k\), \(I_{ta}\), and \(I_{wc}\), which indicate the potential to generate diffuse particles due to kinetic energy, trapped air, and wave crests, respectively.
    To ensure that all the potentials are between 0 and 1, we use a clamping function \(\Phi\) which is defined as
    \[\Phi(I, \tau^{\text{min}}, \tau^{\text{max}}) = \frac{\min(I, \tau^{\max}) - \min(I, \tau^{\min})}{\tau^{\max} - \tau^{\min}}\]
    where \(\tau^{\min}, \tau^{\max}\) are user-defined parameters.
</p>

<p>
    The potentials are calculated by:
</p>
<ul>
    <li>
        \(I_k = \Phi (E_{k, i}, \tau_k^{\text{min}}, \tau_k^{\text{max}})\), where \(E_{k, i} = \frac{1}{2} m_i \|\pmb{v}_i\|^2\) is the kinetic energy of particle \(i\).
    </li>
    <li>
        \(I_{ta} = \Phi (v_i^{\text{diff}}, \tau_{ta}^{\text{min}}, \tau_{ta}^{\text{max}})\), where \(v_i^{\text{diff}} = \sum_j \|\pmb{v}_{ij}\| (1 - \pmb{\hat{v}}_{ij} \cdot \pmb{\hat{x}}_{ij}) W (\pmb{x}_{ij}, h)\), with \(\pmb{v}_{ij} = \pmb{v}_i - \pmb{v}_j\), \(\pmb{x}_{ij} = \pmb{x}_i - \pmb{x}_j\), the hat notation denoting normalization, and 
        \[W (\pmb{x}_{ij}, h) = \begin{cases} 1 - \|\pmb{x}_{ij}\| / h & \|\pmb{x}_{ij}\| \leq h \\ 0 & \text{otherwise} \end{cases}\]
        This assumes that the amount of trapped air is larger if fluid particles move towards each other.
    </li>
    <li>
        \(I_{wc} = \Phi (\tilde{\kappa}_i \cdot \delta_i^{vn}, \tau_{wc}^{\text{min}}, \tau_{wc}^{\text{max}})\), where \(\tilde{\kappa}_i = \sum\limits_{\{ j : \pmb{\hat{x}}_{ji} \cdot \pmb{\hat{n}}_i < 0 \}} (1 - \pmb{\hat{n}}_i \cdot \pmb{\hat{n}}_j) W(\pmb{x}_{ij}, h)\) approximates the curvature and considers only convex regions, and \(\delta_i^{vn} = \begin{cases} 0 & \pmb{\hat{v}}_i \cdot \pmb{\hat{n}}_i < 0.6 \\ 1 & \text{otherwise} \end{cases}\) checks if the fluid particle moves in the normal direction, to prevent situations such as the edges of a cube being considered as wave crests.
    </li>
</ul>
<br>
<p>
    After calculating the potentials,
    \[n_d = I_k (k_{ta} I_{ta} + k_{wc} I_{wc}) \Delta t\]
    gives us the number of diffuse particles that fluid particle \(i\) generates.
    To create the generated diffuse particles, we need two vectors \(\pmb{e}_1'\) and \(\pmb{e}_2'\) which are orthogonal to \(\pmb{v}_i\).
    To achieve this, we decided to use Gram-Schmidt to get \(\pmb{e}_1'\) by orthogonalizing one of the standard unit basis vectors with \(\pmb{v}_i\), and then taking \(\pmb{e}_2' = \pmb{e}_1' \times \pmb{v}_i\).
    We then consider a cylinder with radius equal to the radius of the fluid particle (which we always take to be \(1/10\)), height \(\| \Delta t \pmb{v}_i \|\), and base spanned by \(\pmb{e}_1'\) and \(\pmb{e}_2'\).
    We then place diffuse particles uniformly in that cylinder offset by the fluid particle's position, and we initialize the velocity of the diffuse particle to be \(r \cos \theta \pmb{e}_i' + r \sin \theta \pmb{e}_2' + \pmb{v}_i\), where \(r, \theta\) are the typical cylindrical coordinates.
</p>
<p>
    Finally, for each generated diffuse particle, we classify it as spray if it has less than 6 fluid particle neighbors, bubbles if it has more than 20 fluid particle neighbors, and foam otherwise.
    If it is foam, we initialize its time to live to be \(n_d\), to model the effect of larger foam clusters being more stable than smaller ones.
</p>

<h3>Advection</h3>
<ul>
    <li>
        <b>Spray:</b>
        The motion of spray particles is not affected by water, so the position and velocity update is just performed using Euler's method with any external forces present (in our simulations, we only use gravity).
    </li>
    <li>
        <b>Foam:</b>
        To model a foam particle being transported by the water, we compute the averaged local fluid velocity at the particle's position \(\pmb{x}_d\) as
        \[\pmb{\tilde{v}} (\pmb{x}_d, t + \Delta t) = \frac{\sum_f \frac{\pmb{x}_f (t + \Delta t) - \pmb{x}_f (t)}{\Delta t} \cdot K (\pmb{x}_d -  \pmb{x}_f (t), h)}{ \sum_f K (\pmb{x}_d -  \pmb{x}_f (t), h)}\]
        where \(K\) is the cubic spline kernel defined as
        \[K(\pmb{x}, h) = \sigma \begin{cases} 1 - 1.5 q^2 + 0.75 q^3 & q \leq 1 \\ 0.25 (2 - q)^3 & 1 < q \leq 2 \\ 0 & \text{otherwise} \end{cases}\]
        with \(q = \|\pmb{x}\| / h\) and \(\sigma = \frac{1}{\pi h^3}\).
        <br>
        Because \(\pmb{\tilde{v}} (\pmb{x}_d, t + \Delta t)\) is not defined if there are no fluid neighbors, and the paper does not specify how to handle this case, we decided to erase the particle if this ever happens.
        Then we update the foam particle's position using the averaged local fluid velocity, but we do not update its velocity in order to constrain it to the fluid surface.
    </li>
    <li>
        <b>Bubbles:</b>
        To model buoyancy acting on bubble particles, we update the velocity as
        \[\pmb{v} (t + \Delta t) = \pmb{v}(t) + \Delta t \left( -k_b \pmb{g} + k_d \frac{\pmb{\tilde{v}} (\pmb{x}_d, t + \Delta t) - \pmb{v} (t) }{ \Delta t}  \right)\]
        where \(k_b\) and \(k_d\) are parameters which control buoyancy and drag (in our simulations, we use 0.5 for both).
        Then we update the position accordingly.
    </li>
</ul>

<div align="center">
    <table>
        <tr>
            <td align="middle">
            <img src="images/falling-cube-matplot.gif" width="400px"/>
            <figcaption align="middle">Falling cube with diffuse in Matplotlib</figcaption>
            <td align="middle">
            <img src="images/shower.gif" width="400px"/>
            <figcaption align="middle">Shower with diffuse in Matplotlib</figcaption>
        </tr>
    </table>
</div>

<h2 align="middle">Mesh Generation</h2>

<h3>Marching Cubes</h3>
<p>
    For mesh generation we implemented the marching cubes algorithm. We subdivided the entire object space into a multitude of smaller marching cubes. Then for each marching cube, we take its eight corner points, calculate their isovalues with the iso function and decide if it should render a triangle at an edge connecting to that vertex based on the vertexâ€™s isovalues. Then we generate a OBJ mesh file containing a list of 3D triangle positions and 3D triangle normal values. For our implementation, we also used a subset of code from this website that: provided the list of all 256 different possible triangles we can render, provided a way to generate an index into the triangle list given a passed in cube, and for determining the 3D positions of the triangles.
</p>
<p>
    As part of the mesh generation, we needed to compute the isovalue for each of the voxels (corners of each unit marching cube). Here, we decided to use the density calculation, similar to the one described in fluid-particle generation, to be the isofunction. The isovalue of each voxel is computed by running the isofunction on all the particles within a specific search radius and summing up all the corresponding density. 
</p>
<p>
    For making the animation look more visually pleasing, we computed the normals for each triangle and cube vertex. And to calculate the normals for each cube vertice, we had to calculate the normal vector of 3 different planes so we computed the vector that goes through a vertex and its diagonal vertex counterpart as the normal vector. And for the triangle normals we modified the code subset that we used to calculate the triangle positions to calculate the triangle normals, but with the cube vertex normals we previously calculated as the input.  
</p>
<div align="middle">
    <img src="images/marching.png"/>
    <figcaption align="middle">Unique corner configurations and their corresponding triangles</figcaption>
</div>

<h3>Converting to .obj Files</h3>
<p>
    After running the marching cube algorithm, we are able to generate a list of triangle meshes that represent the surface at each frame. In order to input our meshes into our rendering software, we need to turn triangle meshes into an OBJ file. In order to do this, we need to write code that will write our triangle vertices, normals, and face definitions into a .obj file. The code is relatively straightforward, we write the vertices, normal, and face definition line by line into a file.
</p>
<h2 align="middle">Rendering in Blender</h2>

<div align="middle">
    <img src="images/no-diffuse.gif" align="middle" width="400px"/>
    <figcaption align="middle">Water rendered in Blender (no diffuse particles)</figcaption>
</div>

<h1 align="middle">Problems Encountered</h1>
<h2 align="middle">Tuning Parameters</h2>
<p>
    When we were tuning parameters, we noticed that the denser the particles in our box are the better the resulting mesh. In order to achieve this high density, we need to try to pack a large number of particles in a small box. However, when we try generating a small box we were having issues with the particles blowing up. We decided to resolve this problem by creating a larger box and applying a small constant to the position of the particle to fix them within a smaller space. By doing this, we are not experiencing the blowing-up problem while making the particles denser in our cube.
</p>
<div align="middle">
    <img src="images/badparam.gif" align="middle" width="400px"/>
    <figcaption align="middle">Bad parameters</figcaption>
</div>

<h2 align="middle">Speeding up Marching Cubes</h2>
<h3>Implementing a hashtable for particle neighborhood searching</h3>
<p>
    When we were tuning parameters, we noticed that the denser the particles in our box are the better the resulting mesh. In order to achieve this high density, we need to try to pack a large number of particles in a small box. However, when we try generating a small box we were having issues with the particles blowing up. We decided to resolve this problem by creating a larger box and applying a small constant to the position of the particle to fix them within a smaller space. By doing this, we are not experiencing the blowing-up problem while making the particles denser in our cube.
</p>
<h3>Writing to disk to save memory</h3>
<p>
    Another issue that we encountered when performing marching cubes with many cubes is that our program would run out of memory.
    To solve this, every 100,000 cubes that we iterate through, we write all the results to files and then clear the vector that stores the triangles.
    Finally, at the end, we combine the files into a single <code>.obj</code> file.
</p>

<h3>Storing previously calculated isovalues</h3>
<p>
    To further speed up the program, we store previously calculated isovalues in a map.
    Since up to 8 cubes can share a single vertex, storing these results allows us to avoid redundant calculations.
    However, to avoid running out of memory, we throw away results that will no longer be needed. 
</p>

<h2 align="middle">Using .ply Files to Render Diffuse Particles</h2>
<p>
    Even though we tried to speed up our marching cubes algorithm as much as possible, it was still too slow to generate a mesh fine enough for diffuse particles.
    We tried using OpenVDB to convert the particles to a mesh, but when that did not work, we decided to output the particle positions with <code>.ply</code> files and use Blender's built-in functionality to generate meshes from points.
</p>

<h1 align="middle">Results</h1>
<center><img src="./images/final-diffuse.gif"></center>

<h1 align="middle">Lessons Learned</h1>
<p>
    The lesson we learned was that tuning parameters is a very important and time consuming process that directly determines the quality of the final output no matter how good the code is. The method we used for tuning parameters for the marching cubes algorithm was trial and error. And the method we used for tuning the particle physics simulation parameters was by using a jupyter notebook script that automated the tuning process, along with inputting the results into matplotlib to visually verify the quality of the output based on our parameters. Both methods of parameter tuning still took longer than we expected.
</p>
<h1 align="middle">References</h1>
<ul>
    <li>
        <a href="http://mmacklin.com/pbf_sig_preprint.pdf" target="_blank" rel="noopener noreferrer">Position Based Fluids</a>
    </li>
    <li>
        <a href="https://cg.informatik.uni-freiburg.de/publications/2012_CGI_sprayFoamBubbles.pdf" target="_blank" rel="noopener noreferrer">Unified Spray, Foam and Bubbles for Particle-Based Fluids</a>
    </li>
    <li>
        <a href="https://matthias-research.github.io/pages/publications/sca03.pdf" target="_blank" rel="noopener noreferrer">Particle-Based Fluid Simulation for Interactive Applications</a>
    </li>
    <li>
        <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.302.1856&rep=rep1&type=pdf" target="_blank" rel="noopener noreferrer">SPH: Towards Flood Simulations</a>
    </li>

    <li>
        <a href="http://paulbourke.net/geometry/polygonise/" target="_blank" rel="noopener noreferrer">Polygonising a scalar field</a>
    </li>
    <li>
        <a href="https://people.eecs.berkeley.edu/~jrs/meshpapers/LorensenCline.pdf/" target="_blank" rel="noopener noreferrer">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</a>
    </li>
    

    
</ul>

<h1 align="middle">Contributions</h1>
<ul>
    <li>
        <b>Joshua Chen:</b>
        Worked on particle fluid simulation and diffuse particle simulation.
        Worked on speeding up Marching Cubes.
        Determined how to render diffuse particles in Blender.
    </li>
    <li><b>Marcus Lee:</b> </li>
    <li>
        <b>Calvin Pham:</b>
        Worked on the implementation of marching cubes algorithm.
        Worked on marching cubes cube generation and normals calculations.
        Worked on tuning marching cubes input parameters.
    </li>
    <li>
        <b>Fourth Teerakapibal:</b>
        Worked on creating isofunction for voxel isovalue calculation.
        Worked on turning parameters for marching cubes and hashtable for speedup.
        Worked on converting triangle meshes to OBJ file.
    </li>
</ul>

</body>
</html>